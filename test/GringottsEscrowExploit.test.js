const { ethers } = require('hardhat');
const { expect } = require('chai');
const { BigNumber } = require('ethers');
const { utils } = ethers;

describe('GringottsEscrow', function () {
  let GringottsEscrow;
  let hardhatGringottsEscrow;
  let addr1, addr2;
  let lastestBlock;

  let secret;
  let secretHash;
  let anotherSecretHash;

  beforeEach(async () => {
    GringottsEscrow = await ethers.getContractFactory('GringottsEscrow');
    hardhatGringottsEscrow = await GringottsEscrow.deploy();

    secret = 'secret';
    secretHash = utils.keccak256(
      utils.solidityPack(
        ['string', 'address'],
        [secret, hardhatGringottsEscrow.address.toLowerCase()],
      ),
    );
    anotherSecretHash = utils.keccak256(
      utils.solidityPack(
        ['string', 'address'],
        ['anotherSecret', hardhatGringottsEscrow.address.toLowerCase()],
      ),
    );

    GringottsEscrowExploit = await ethers.getContractFactory(
      'GringottsEscrowExploit',
    );
    [addr1, addr2] = await ethers.getSigners();

    hardhatGringottsEscrowExploit = await GringottsEscrowExploit.deploy(
      hardhatGringottsEscrow.address,
    );
    lastestBlock = await ethers.provider.getBlock('latest');
  });

  describe('deposit', () => {
    it('should not be able to still all ether from contract', async () => {
      await hardhatGringottsEscrow
        .connect(addr1)
        .deposit(anotherSecretHash, lastestBlock.timestamp + 7200, {
          value: ethers.utils.parseEther('100'),
        });

      await hardhatGringottsEscrow
        .connect(addr2)
        .deposit(secretHash, lastestBlock.timestamp + 3600, {
          value: ethers.utils.parseEther('1'),
        });

      await expect(
        hardhatGringottsEscrowExploit.connect(addr2).attack(secret),
      ).to.be.revertedWith('ReentrancyGuard: reentrant call');
    });
  });
});
